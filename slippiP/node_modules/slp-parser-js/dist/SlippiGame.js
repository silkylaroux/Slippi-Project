"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _slpReader = require("./utils/slpReader");

var _common = require("./stats/common");

var _conversions = require("./stats/conversions");

var _combos = require("./stats/combos");

var _stocks = require("./stats/stocks");

var _actions = require("./stats/actions");

var _overall = require("./stats/overall");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Slippi Game class that wraps a file
 */
class SlippiGame {
  constructor(input) {
    if (_lodash.default.isString(input)) {
      this.input = {
        source: 'file',
        filePath: input
      };
    } else if (input instanceof Buffer) {
      this.input = {
        source: 'buffer',
        buffer: input
      };
    } else {
      throw new Error("Cannot create SlippiGame with input of that type");
    }

    this.frameReadPos = null;
    this.latestFrameIndex = null;
  }
  /**
   * Gets the game settings, these are the settings that describe the starting state of
   * the game such as characters, stage, etc.
   */


  getSettings() {
    if (this.settings) {
      // If header is already generated, return it
      return this.settings;
    }

    const slpfile = (0, _slpReader.openSlpFile)(this.input); // Prepare default settings

    let settings = {
      stageId: 0,
      isTeams: false,
      isPAL: false,
      players: []
    }; // Generate settings from iterating through file

    (0, _slpReader.iterateEvents)(slpfile, (command, payload) => {
      if (!payload) {
        // If payload is falsy, keep iterating. The parser probably just doesn't know
        // about this command yet
        return false;
      }

      switch (command) {
        case _slpReader.Commands.GAME_START:
          if (!payload.stageId) {
            return true; // Why do I have to do this? Still not sold on Flow
          }

          settings = payload;
          settings.players = _lodash.default.filter(payload.players, player => player.type !== 3);
          break;

        case _slpReader.Commands.POST_FRAME_UPDATE:
          if (payload.frame === null || payload.frame > _common.Frames.FIRST) {
            // Once we are an frame -122 or higher we are done getting match settings
            // Tell the iterator to stop
            return true;
          }

          const playerIndex = payload.playerIndex;

          const playersByIndex = _lodash.default.keyBy(settings.players, 'playerIndex');

          switch (payload.internalCharacterId) {
            case 0x7:
              playersByIndex[playerIndex].characterId = 0x13; // Sheik

              break;

            case 0x13:
              playersByIndex[playerIndex].characterId = 0x12; // Zelda

              break;
          }

          break;
      }

      return false; // Tell the iterator to keep iterating
    });
    this.settings = settings;
    (0, _slpReader.closeSlpFile)(slpfile);
    return settings;
  }

  getLatestFrame() {
    // TODO: Modify this to check if we actually have all the latest frame data and return that
    // TODO: If we do. For now I'm just going to take a shortcut
    const allFrames = this.getFrames();
    const frameIndex = this.latestFrameIndex || _common.Frames.FIRST;
    const indexToUse = this.gameEnd ? frameIndex : frameIndex - 1;
    return _lodash.default.get(allFrames, indexToUse) || null;
  }

  getGameEnd() {
    if (this.gameEnd) {
      return this.gameEnd;
    } // Trigger getFrames because that is where the flag is set


    this.getFrames();
    return this.gameEnd || null;
  }

  getFrames() {
    if (this.playerFrames && this.gameEnd) {
      // If game end has been detected, we can returned cached version of frames
      return this.playerFrames;
    }

    const slpfile = (0, _slpReader.openSlpFile)(this.input);
    const playerFrames = this.playerFrames || {};
    const followerFrames = this.followerFrames || {};
    this.frameReadPos = (0, _slpReader.iterateEvents)(slpfile, (command, payload) => {
      if (!payload) {
        // If payload is falsy, keep iterating. The parser probably just doesn't know
        // about this command yet
        return false;
      }

      switch (command) {
        case _slpReader.Commands.PRE_FRAME_UPDATE:
        case _slpReader.Commands.POST_FRAME_UPDATE:
          if (!payload.frame && payload.frame !== 0) {
            // If payload is messed up, stop iterating. This shouldn't ever happen
            return true;
          }

          const location = command === _slpReader.Commands.PRE_FRAME_UPDATE ? "pre" : "post";
          const frames = payload.isFollower ? followerFrames : playerFrames;
          this.latestFrameIndex = payload.frame;

          _lodash.default.set(frames, [payload.frame, 'players', payload.playerIndex, location], payload);

          _lodash.default.set(frames, [payload.frame, 'frame'], payload.frame);

          break;

        case _slpReader.Commands.GAME_END:
          this.gameEnd = payload;
          break;
      }

      return false; // Tell the iterator to keep iterating
    }, this.frameReadPos);
    this.playerFrames = playerFrames;
    this.followerFrames = followerFrames;
    (0, _slpReader.closeSlpFile)(slpfile);
    return playerFrames;
  }

  getStats() {
    if (this.stats && this.stats.gameComplete) {
      // If game end has been detected, we can returned cached version stats since they wont change
      return this.stats;
    }

    const slpfile = (0, _slpReader.openSlpFile)(this.input);
    const lastFrame = (0, _common.getLastFrame)(this); // The order here kind of matters because things later in the call order might
    // reference things calculated earlier. More specifically, currently the overall
    // calculation uses the others

    this.stats = {};
    this.stats.stocks = (0, _stocks.generateStocks)(this);
    this.stats.conversions = (0, _conversions.generateConversions)(this);
    this.stats.combos = (0, _combos.generateCombos)(this);
    this.stats.actionCounts = (0, _actions.generateActionCounts)(this);
    this.stats.lastFrame = lastFrame;
    this.stats.playableFrameCount = lastFrame + Math.abs(_common.Frames.FIRST_PLAYABLE);
    this.stats.overall = (0, _overall.generateOverall)(this);
    this.stats.gameComplete = !!this.gameEnd;
    (0, _slpReader.closeSlpFile)(slpfile);
    return this.stats;
  }

  getMetadata() {
    if (this.metadata) {
      return this.metadata;
    }

    const slpfile = (0, _slpReader.openSlpFile)(this.input);
    this.metadata = (0, _slpReader.getMetadata)(slpfile);
    (0, _slpReader.closeSlpFile)(slpfile);
    return this.metadata;
  }

}

exports.default = SlippiGame;