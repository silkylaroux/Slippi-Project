"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateActionCounts = generateActionCounts;

var _lodash = _interopRequireDefault(require("lodash"));

var _index = _interopRequireDefault(require("../index"));

var _common = require("./common");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isRolling(animation) {
  const rollAnimations = {
    [_common.States.ROLL_BACKWARD]: true,
    [_common.States.ROLL_FORWARD]: true
  };
  return rollAnimations[animation];
}

function didStartRoll(currentAnimation, previousAnimation) {
  const isCurrentlyRolling = isRolling(currentAnimation);
  const wasPreviouslyRolling = isRolling(previousAnimation);
  return isCurrentlyRolling && !wasPreviouslyRolling;
}

function isSpotDodging(animation) {
  return animation === _common.States.SPOT_DODGE;
}

function didStartSpotDodge(currentAnimation, previousAnimation) {
  const isCurrentlyDodging = isSpotDodging(currentAnimation);
  const wasPreviouslyDodging = isSpotDodging(previousAnimation);
  return isCurrentlyDodging && !wasPreviouslyDodging;
}

function isAirDodging(animation) {
  return animation === _common.States.AIR_DODGE;
}

function didStartAirDodge(currentAnimation, previousAnimation) {
  const isCurrentlyDodging = isAirDodging(currentAnimation);
  const wasPreviouslyDodging = isAirDodging(previousAnimation);
  return isCurrentlyDodging && !wasPreviouslyDodging;
}

function generateActionCounts(game) {
  const actionCounts = []; // Frame pattern that indicates a dash dance turn was executed

  const dashDanceAnimations = [_common.States.DASH, _common.States.TURN, _common.States.DASH];
  const initialState = {
    animations: [],
    playerCounts: null
  };
  let state = initialState; // Helper function for incrementing counts

  const incrementCount = (field, condition) => {
    if (!condition) {
      return;
    }

    state.playerCounts[field] += 1;
  }; // Iterates the frames in order in order to compute stocks


  (0, _common.iterateFramesInOrder)(game, indices => {
    const playerCounts = {
      playerIndex: indices.playerIndex,
      opponentIndex: indices.opponentIndex,
      wavedashCount: 0,
      wavelandCount: 0,
      airDodgeCount: 0,
      dashDanceCount: 0,
      spotDodgeCount: 0,
      rollCount: 0
    };
    state = { ...initialState,
      playerCounts: playerCounts
    };
    actionCounts.push(playerCounts);
  }, (indices, frame) => {
    const playerFrame = frame.players[indices.playerIndex].post; // Manage animation state

    state.animations.push(playerFrame.actionStateId); // Grab last 3 frames

    const last3Frames = state.animations.slice(-3);
    const currentAnimation = playerFrame.actionStateId;
    const prevAnimation = last3Frames[last3Frames.length - 2]; // Increment counts based on conditions

    const didDashDance = _lodash.default.isEqual(last3Frames, dashDanceAnimations);

    incrementCount('dashDanceCount', didDashDance);
    const didRoll = didStartRoll(currentAnimation, prevAnimation);
    incrementCount('rollCount', didRoll);
    const didSpotDodge = didStartSpotDodge(currentAnimation, prevAnimation);
    incrementCount('spotDodgeCount', didSpotDodge);
    const didAirDodge = didStartAirDodge(currentAnimation, prevAnimation);
    incrementCount('airDodgeCount', didAirDodge); // Handles wavedash detection (and waveland)

    handleActionWavedash(state.playerCounts, state.animations, frame.frame);
  });
  return actionCounts;
}

function handleActionWavedash(counts, animations) {
  const currentAnimation = _lodash.default.last(animations);

  const prevAnimation = animations[animations.length - 2];
  const isSpecialLanding = currentAnimation === _common.States.LANDING_FALL_SPECIAL;
  const isAcceptablePrevious = isWavedashInitiationAnimation(prevAnimation);
  const isPossibleWavedash = isSpecialLanding && isAcceptablePrevious;

  if (!isPossibleWavedash) {
    return;
  } // Here we special landed, it might be a wavedash, let's check
  // We grab the last 8 frames here because that should be enough time to execute a
  // wavedash. This number could be tweaked if we find false negatives


  const recentFrames = animations.slice(-8);

  const recentAnimations = _lodash.default.keyBy(recentFrames, animation => animation);

  if (_lodash.default.size(recentAnimations) === 2 && recentAnimations[_common.States.AIR_DODGE]) {
    // If the only other animation is air dodge, this might be really late to the point
    // where it was actually an air dodge. Air dodge animation is really long
    return;
  }

  if (recentAnimations[_common.States.AIR_DODGE]) {
    // If one of the recent animations was an air dodge, let's remove that from the
    // air dodge counter, we don't want to count air dodges used to wavedash/land
    counts.airDodgeCount -= 1;
  }

  if (recentAnimations[_common.States.ACTION_KNEE_BEND]) {
    // If a jump was started recently, we will consider this a wavedash
    counts.wavedashCount += 1;
  } else {
    // If there was no jump recently, this is a waveland
    counts.wavelandCount += 1;
  }
}

function isWavedashInitiationAnimation(animation) {
  if (animation === _common.States.AIR_DODGE) {
    return true;
  }

  const isAboveMin = animation >= _common.States.CONTROLLED_JUMP_START;
  const isBelowMax = animation <= _common.States.CONTROLLED_JUMP_END;
  return isAboveMin && isBelowMax;
}