"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateStocks = generateStocks;

var _lodash = _interopRequireDefault(require("lodash"));

var _index = _interopRequireDefault(require("../index"));

var _common = require("./common");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function generateStocks(game) {
  const stocks = [];
  const frames = game.getFrames();
  const initialState = {
    stock: null
  };
  let state = initialState; // Iterates the frames in order in order to compute stocks

  (0, _common.iterateFramesInOrder)(game, () => {
    state = { ...initialState
    };
  }, (indices, frame) => {
    const playerFrame = frame.players[indices.playerIndex].post;

    const prevPlayerFrame = _lodash.default.get(frames, [playerFrame.frame - 1, 'players', indices.playerIndex, 'post'], {}); // If there is currently no active stock, wait until the player is no longer spawning.
    // Once the player is no longer spawning, start the stock


    if (!state.stock) {
      const isPlayerDead = (0, _common.isDead)(playerFrame.actionStateId);

      if (isPlayerDead) {
        return;
      }

      state.stock = {
        playerIndex: indices.playerIndex,
        opponentIndex: indices.opponentIndex,
        startFrame: playerFrame.frame,
        endFrame: null,
        startPercent: 0,
        endPercent: null,
        currentPercent: 0,
        count: playerFrame.stocksRemaining,
        deathAnimation: null
      };
      stocks.push(state.stock);
    } else if ((0, _common.didLoseStock)(playerFrame, prevPlayerFrame)) {
      state.stock.endFrame = playerFrame.frame;
      state.stock.endPercent = prevPlayerFrame.percent || 0;
      state.stock.deathAnimation = playerFrame.actionStateId;
      state.stock = null;
    } else {
      state.stock.currentPercent = playerFrame.percent || 0;
    }
  });
  return stocks;
}